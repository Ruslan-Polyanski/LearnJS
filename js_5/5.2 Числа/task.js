
let billion1 = 1000000000;
let billion2 = 1_000_000_000;

let billion3 = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей
console.log( 7.3e9 );  // 7.3 миллиарда (7,300,000,000)

// Другими словами, "e" умножает число на 1 с указанным количеством нулей.
console.log(1e3 === 1 * 1000) // e3 означает *1000
console.log(1.23e6 === 1.23 * 1000000) // e6 означает *1000000

let mcs = 0.000001;
let ms = 1e-6; // шесть нулей слева от 1

// 1 делится на 1 с 3 нулями
console.log(1e-3 === 1 / 1000) (0.001)

// 1.23 делится на 1 с 6 нулями
console.log(1.23e-6 === 1.23 / 1000000) (0.00000123)

console.log( 0xff ); // 255
console.log( 0xFF ); // 255 (то же самое, регистр не имеет значения)

let a = 0b11111111; // двоичная (бинарная) форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

console.log( a == b ); // true, с двух сторон число 255

// Метод num.toString(base) возвращает строковое представление числа num в системе счисления base

let num = 255;
console.log( num.toString(16) );  // ff
console.log( num.toString(2) );   // 11111111

// base может варьироваться от 2 до 36 (по умолчанию 10).

console.log( 123456..toString(36) ); // 2n9c

// Внимание! Две точки в 123456..toString(36) это не опечатка. 
// Если нам надо вызвать метод непосредственно на числе, как toString в примере выше, 
// то нам надо поставить две точки .. после числа.
// Если мы поставим одну точку: 123456.toString(36), тогда это будет ошибкой, 
// поскольку синтаксис JavaScript предполагает, 
// что после первой точки начинается десятичная часть. 
// А если поставить две точки, то JavaScript понимает, что десятичная часть отсутствует, 
// и начинается метод.
// Также можно записать как (123456).toString(36).

Math.floor // Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
Math.ceil  // Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
Math.round // Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.
Math.trunc // Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.

let num1 = 1.23456;
console.log( Math.round(num1 * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23

let num2 = 12.34;
console.log( num2.toFixed(1) ); // "12.3"

let num3 = 12.36;
console.log( num3.toFixed(1) ); // "12.4"

let num4 = 12.34;
console.log( num.toFixed(5) ); // "12.34000", добавлены нули, чтобы получить 5 знаков после запятой

// Мы можем преобразовать полученное значение в число, используя унарный оператор + или Number(), 
// пример с унарным оператором: +num.toFixed(5)

console.log( 1e500 ); // Infinity

console.log( 0.1 + 0.2 == 0.3 ); // false
console.log( 0.1 + 0.2 ); // 0.30000000000000004

console.log( 0.1.toFixed(20) ); // 0.10000000000000000555

let sum = 0.1 + 0.2;
console.log( sum.toFixed(2) ); // 0.30

let sum2 = 0.1 + 0.2;
console.log( +sum2.toFixed(2) ); // 0.3

console.log( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
console.log( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001

// Привет! Я – число, растущее само по себе!
console.log( 9999999999999999 ); // покажет 10000000000000000

// isNaN(value) преобразует значение в число и проверяет является ли оно NaN
console.log( isNaN(NaN) ); // true
console.log( isNaN("str") ); // true

console.log( NaN === NaN ); // false

// isFinite(value) преобразует аргумент в число и возвращает true, 
// если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:

console.log( isFinite("15") ); // true
console.log( isFinite("str") ); // false, потому что специальное значение: NaN
console.log( isFinite(Infinity) ); // false, потому что специальное значение: Infinity

let num5 = +prompt("Введите число:", '');
// вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число
console.log( isFinite(num5) );

console.log( +"100px" ); // NaN

// parseInt и parseFloat «читают» число из строки
console.log( parseInt('100px') ); // 100
console.log( parseFloat('12.5em') ); // 12.5

console.log( parseInt('12.3') ); // 12, вернётся только целая часть
console.log( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке

// Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру:
console.log( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения

console.log( parseInt('0xff', 16) ); // 255
console.log( parseInt('ff', 16) ); // 255, без 0x тоже работает
console.log( parseInt('2n9c', 36) ); // 123456

console.log( Math.random() ); // 0.1234567894322
console.log( Math.random() ); // 0.5435252343232
console.log( Math.random() ); // ... (любое количество псевдослучайных чисел)

console.log( Math.max(3, 5, -10, 0, 1) ); // 5
console.log( Math.min(1, 2) ); // 1

console.log( Math.pow(2, 10) ); // 2 в степени 10 = 1024



